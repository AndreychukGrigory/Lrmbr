# Лабораторная работа №1 
Расчёт контрольной суммы
1. Создаём скрипт perl

![Скрипт perl](2.png)
2. Прописываем в терминале команду sha256sum script.pl
![Хэш-сумма](Screenshot_11.png)

Для проверки изменения контрольной суммы, откроем скрипт в nano и добавим комментарий
![Добавление комментария](3.png)

Снова прописываем в терминале sha256sum script.pl
![Хэш-сумма с комментарием](12.png)

# Вывод
Контрольная сумма файла изменилась после редактирования, даже несмотря на то, что была добавлена лишь строка комментария. Это подтверждает, что хэш-функции чувствительны к любым изменениям содержимого файла и позволяют надёжно отслеживать целостность данных.

# Лабораторная работа №2
Фаззинг-тестирование
1. Установка зависимостей
```
sudo apt update
sudo apt install build-essential clang llvm-dev libstdc++-dev -y
```
2. Клонирование репозитория
```
git clone https://github.com/AFLplusplus/AFLplusplus.git
cd AFLplusplus
```
3. Компиляция и установка
```
make all
sudo make install
```
Проверим установленные компиляторы
```
ls -l afl-*
```
![компиляторы](8.png)
4. Создание C-обертки wrapper.c

Обоснование использования C-обертки с инструментацией:
- **Проблема совместимости архитектур.**
Скрипт script.pl является текстовым файлом, исполняемым интерпретатором /usr/bin/perl, и не может быть скомпилирован afl-cc напрямую.
- **Управление потоками ввода.**
Целевой Perl-скрипт ожидает данные через стандартный ввод (STDIN). AFL++ по умолчанию генерирует входные данные в виде файлов. Обертка wrapper.c эффективно решает задачу перенаправления: она принимает путь к файлу от AFL++ (через аргумент @@) и перенаправляет его содержимое в STDIN перед вызовом интерпретатора Perl

С помощью nano создаём wrapper.c и вводим код, который будет служить точкой входа для фаззера.
![wrapper.c](14.png)

5. Компиляция С-обертки с инструментацией
C-обертка была скомпилирована с использованием компилятора AFL++ (afl-cc) для добавления необходимой инструментации (LLVM-PCGUARD).
```
/home/grigory/security_lab/AFLplusplus/afl-cc wrapper.c -o fuzzed_perl
```
6. Подготовка стартового корпуса
Для повышения эффективности фаззинга был подготовлен минимальный набор входных файлов, покрывающий основные логические ветви скрипта script.pl
```
mkdir in
echo "DATA:123.45" > in/seed_data
echo "INVALID_FORMAT" > in/seed_invalid
echo "USER:admin" > in/seed_user
```
7. Запуск фаззинг-тестирования
Фаззер был запущен в режиме Dumb Fuzzing (-D), указывая на собранный корпус (in) и выходной каталог (out).
```
sudo /home/grigory/security_lab/AFLplusplus/afl-fuzz -D -i in -o out -- ./fuzzed_perl @@
```
![Начало фаззинга](Screenshot_6.png)

Процесс фаззинг-тестирования завершился через короткий промежуток времени (около 5 минут) с статусом "Finished".

![Конец фаззинга](Screenshot_7.png)

# Вывод
В данной лабораторной работе была решена задача фаззинг-тестирования приложения, написанного на интерпретируемом языке Perl. С помощью инструмента AFL++ и специально написанной программы-обертки на языке C удалось подать на вход скрипта множество мутированных данных. Тестирование показало устойчивость скрипта: за время работы фаззера аварийных завершений (crashes) зафиксировано не было. Также были изучены ограничения метода "черного ящика" (Dumb Fuzzing), который, не имея доступа к внутренней структуре Perl-скрипта, проводит поверхностное, но быстрое тестирование на отказ в обслуживании и ошибки валидации ввода.

